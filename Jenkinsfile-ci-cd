pipeline {
  agent { label 'slave01' }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '5'))
    timeout(time: 10, unit: 'MINUTES')
    skipDefaultCheckout(true)
  }

  environment {
    // --- Repo z aplikacją ---
    REPO_URL              = 'https://github.com/patrykostrzyckicoi/app-test.git'
    GITHUB_CREDENTIALS_ID = 'access-token-jenkins-patryk-ostrzycki'

    // --- Ścieżki w repo app-test ---
    BASE_DIR        = '.'
    APP_DIR         = 'app'
    DOCKERFILE_PATH = 'Dockerfile'

    // --- Registry: GHCR ---
    REGISTRY_HOST        = 'ghcr.io'
    IMAGE_REPO           = 'ghcr.io/patrykostrzyckicoi/app-test'
    REGISTRY_CREDENTIALS = 'access-token-jenkins-patryk-ostrzycki'
  }

  stages {
    stage('Checkout') {
      steps {
        git url: env.REPO_URL, branch: 'master',
            changelog: true, poll: true,
            credentialsId: env.GITHUB_CREDENTIALS_ID
        sh 'git --version'
      }
    }

    stage('Test (pytest)') {
      agent {
        docker {
          image 'python:3.11-slim'
          args  '-u 0:0'
        }
      }
      steps {
        dir(env.APP_DIR) {
          sh '''
            set -eux
            python -m pip install --upgrade pip
            pip install -r requirements.txt
            mkdir -p reports
            pytest -q --junitxml=reports/junit.xml
          '''
          junit 'reports/junit.xml'
        }
      }
    }

    stage('Build Docker image') {
      steps {
        script {
          env.GIT_SHA       = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE_TAG     = "${env.IMAGE_REPO}:${env.GIT_SHA}"
          env.IMAGE_LATEST  = "${env.IMAGE_REPO}:latest"
          echo "Building ${env.IMAGE_TAG} (and tagging as latest)"
        }
        sh '''
          set -eux
          docker build \
            -f "${DOCKERFILE_PATH}" \
            -t "${IMAGE_TAG}" \
            -t "${IMAGE_LATEST}" \
            "${BASE_DIR}"
        '''
      }
    }

    stage('Push image') {
      steps {
        withCredentials([usernamePassword(credentialsId: env.REGISTRY_CREDENTIALS,
                                          usernameVariable: 'REG_USER',
                                          passwordVariable: 'REG_PASS')]) {
          sh '''
            set -eux
            echo "$REG_PASS" | docker login "${REGISTRY_HOST}" -u "$REG_USER" --password-stdin
            docker push "${IMAGE_TAG}"
            docker push "${IMAGE_LATEST}"
            docker logout "${REGISTRY_HOST}"
          '''
        }
      }
    }

    stage('Deploy & smoke-test') {
      steps {
        script {
          def rnd = new Random()
          env.APP_PORT = (10000 + rnd.nextInt(10000)).toString()
        }
        sh '''
          set -eux
          CID=$(docker run -d -p "${APP_PORT}:9000" "${IMAGE_TAG}")   # <-- 9000 (port aplikacji)
          # czekamy aż aplikacja wstanie (max ~30s)
          for i in $(seq 1 30); do
            if curl -fsS "http://localhost:${APP_PORT}/health" >/dev/null 2>&1; then break; fi
            sleep 1
          done
          RESP=$(curl -fsS "http://localhost:${APP_PORT}/health" || true)
          echo "Health response: $RESP"
          if [ "$RESP" != '{"status":"ok"}' ] && [ "$RESP" != '{"status": "ok"}' ]; then
            echo "Healthcheck failed, dumping container logs:"
            docker logs "$CID" || true
            docker rm -f "$CID"
            exit 56
          fi
          docker rm -f "$CID"
        '''
      }
    }
  }

  post {
    always {
      cleanWs()
    }
  }
}
